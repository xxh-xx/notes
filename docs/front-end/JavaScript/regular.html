<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>正则表达式 | Some Notes</title>
    <meta name="generator" content="VuePress 1.9.5">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/notes/assets/css/0.styles.df554011.css" as="style"><link rel="preload" href="/notes/assets/js/app.98e544da.js" as="script"><link rel="preload" href="/notes/assets/js/2.5375f91f.js" as="script"><link rel="preload" href="/notes/assets/js/14.89fb7710.js" as="script"><link rel="prefetch" href="/notes/assets/js/10.0753cc9f.js"><link rel="prefetch" href="/notes/assets/js/11.0b2d326e.js"><link rel="prefetch" href="/notes/assets/js/12.197a8347.js"><link rel="prefetch" href="/notes/assets/js/13.f0d0efc4.js"><link rel="prefetch" href="/notes/assets/js/3.b694de4d.js"><link rel="prefetch" href="/notes/assets/js/4.d1188e69.js"><link rel="prefetch" href="/notes/assets/js/5.af02128b.js"><link rel="prefetch" href="/notes/assets/js/6.a8a31aa8.js"><link rel="prefetch" href="/notes/assets/js/7.ef983566.js"><link rel="prefetch" href="/notes/assets/js/8.03b6b307.js"><link rel="prefetch" href="/notes/assets/js/9.c46dcef6.js">
    <link rel="stylesheet" href="/notes/assets/css/0.styles.df554011.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/notes/" class="home-link router-link-active"><!----> <span class="site-name">Some Notes</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端菜单" class="dropdown-title"><span class="title">前端</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端菜单" class="mobile-dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/notes/front-end/CSS/transform.html" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/notes/front-end/JavaScript/ES6.html" class="nav-link">
  JavaScript
</a></li></ul></div></div><div class="nav-item"><a href="https://xxh-xx.github.io/notes/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端菜单" class="dropdown-title"><span class="title">前端</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端菜单" class="mobile-dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/notes/front-end/CSS/transform.html" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/notes/front-end/JavaScript/ES6.html" class="nav-link">
  JavaScript
</a></li></ul></div></div><div class="nav-item"><a href="https://xxh-xx.github.io/notes/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>JavaScript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/front-end/JavaScript/ES6.html" class="sidebar-link">ES6</a></li><li><a href="/notes/front-end/JavaScript/regular.html" aria-current="page" class="active sidebar-link">正则表达式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/front-end/JavaScript/regular.html#匹配时忽略大小写" class="sidebar-link">匹配时忽略大小写</a></li><li class="sidebar-sub-header"><a href="/notes/front-end/JavaScript/regular.html#提取匹配项" class="sidebar-link">提取匹配项</a></li><li class="sidebar-sub-header"><a href="/notes/front-end/JavaScript/regular.html#全局匹配" class="sidebar-link">全局匹配</a></li><li class="sidebar-sub-header"><a href="/notes/front-end/JavaScript/regular.html#用通配符匹配任何内容" class="sidebar-link">用通配符匹配任何内容</a></li><li class="sidebar-sub-header"><a href="/notes/front-end/JavaScript/regular.html#将单个字符与多种可能性匹配" class="sidebar-link">将单个字符与多种可能性匹配</a></li><li class="sidebar-sub-header"><a href="/notes/front-end/JavaScript/regular.html#匹配字母表中的字母" class="sidebar-link">匹配字母表中的字母</a></li><li class="sidebar-sub-header"><a href="/notes/front-end/JavaScript/regular.html#匹配字母表中的数字和字母" class="sidebar-link">匹配字母表中的数字和字母</a></li><li class="sidebar-sub-header"><a href="/notes/front-end/JavaScript/regular.html#匹配单个未指定的字符" class="sidebar-link">匹配单个未指定的字符</a></li><li class="sidebar-sub-header"><a href="/notes/front-end/JavaScript/regular.html#匹配出现一次或多次的字符" class="sidebar-link">匹配出现一次或多次的字符</a></li><li class="sidebar-sub-header"><a href="/notes/front-end/JavaScript/regular.html#匹配出现零次或多次的字符" class="sidebar-link">匹配出现零次或多次的字符</a></li><li class="sidebar-sub-header"><a href="/notes/front-end/JavaScript/regular.html#用惰性匹配来查找字符" class="sidebar-link">用惰性匹配来查找字符</a></li><li class="sidebar-sub-header"><a href="/notes/front-end/JavaScript/regular.html#匹配字符串的开头" class="sidebar-link">匹配字符串的开头</a></li><li class="sidebar-sub-header"><a href="/notes/front-end/JavaScript/regular.html#匹配字符串的末尾" class="sidebar-link">匹配字符串的末尾</a></li><li class="sidebar-sub-header"><a href="/notes/front-end/JavaScript/regular.html#匹配所有的字母和数字" class="sidebar-link">匹配所有的字母和数字</a></li><li class="sidebar-sub-header"><a href="/notes/front-end/JavaScript/regular.html#匹配除了字母和数字的所有符号" class="sidebar-link">匹配除了字母和数字的所有符号</a></li><li class="sidebar-sub-header"><a href="/notes/front-end/JavaScript/regular.html#匹配所有数字" class="sidebar-link">匹配所有数字</a></li><li class="sidebar-sub-header"><a href="/notes/front-end/JavaScript/regular.html#匹配所有非数字" class="sidebar-link">匹配所有非数字</a></li><li class="sidebar-sub-header"><a href="/notes/front-end/JavaScript/regular.html#匹配空白字符" class="sidebar-link">匹配空白字符</a></li><li class="sidebar-sub-header"><a href="/notes/front-end/JavaScript/regular.html#匹配非空白字符" class="sidebar-link">匹配非空白字符</a></li><li class="sidebar-sub-header"><a href="/notes/front-end/JavaScript/regular.html#指定匹配的上限和下限" class="sidebar-link">指定匹配的上限和下限</a></li><li class="sidebar-sub-header"><a href="/notes/front-end/JavaScript/regular.html#只指定匹配的下限" class="sidebar-link">只指定匹配的下限</a></li><li class="sidebar-sub-header"><a href="/notes/front-end/JavaScript/regular.html#指定匹配的确切数量" class="sidebar-link">指定匹配的确切数量</a></li><li class="sidebar-sub-header"><a href="/notes/front-end/JavaScript/regular.html#检查全部或无" class="sidebar-link">检查全部或无</a></li><li class="sidebar-sub-header"><a href="/notes/front-end/JavaScript/regular.html#正向先行断言和负向先行断言" class="sidebar-link">正向先行断言和负向先行断言</a></li><li class="sidebar-sub-header"><a href="/notes/front-end/JavaScript/regular.html#检查混合字符组" class="sidebar-link">检查混合字符组</a></li><li class="sidebar-sub-header"><a href="/notes/front-end/JavaScript/regular.html#使用捕获组重用模式" class="sidebar-link">使用捕获组重用模式</a></li><li class="sidebar-sub-header"><a href="/notes/front-end/JavaScript/regular.html#使用捕获组搜索和替换" class="sidebar-link">使用捕获组搜索和替换</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="正则表达式"><a href="#正则表达式" class="header-anchor">#</a> 正则表达式</h1> <h2 id="匹配时忽略大小写"><a href="#匹配时忽略大小写" class="header-anchor">#</a> 匹配时忽略大小写</h2> <p>大小写即大写字母和小写字母。 大写字母如 <code>A</code>、<code>B</code> 和 <code>C</code>。 小写字母如 <code>a</code>、<code>b</code> 和 <code>c</code>。</p> <p>可以使用标志（flag）来匹配这两种情况。 标志有很多，不过这里我们只关注忽略大小写的标志——<code>i</code>。 可以通过将它附加到正则表达式之后来使用它。 这里给出使用该标志的一个实例 <code>/ignorecase/i</code>。 这个字符串可以匹配字符串 <code>ignorecase</code>、<code>igNoreCase</code> 和 <code>IgnoreCase</code>。</p> <h2 id="提取匹配项"><a href="#提取匹配项" class="header-anchor">#</a> 提取匹配项</h2> <p>到目前为止，只是检查了一个匹配模式是否存在于字符串中。 还可以使用 <code>.match()</code> 方法来提取找到的实际匹配项。</p> <p>可以使用字符串来调用 <code>.match()</code> 方法，并在括号内传入正则表达式。</p> <p>请看下面的举例：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token string">&quot;Hello, World!&quot;</span><span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">Hello</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> ourStr <span class="token operator">=</span> <span class="token string">&quot;Regular expressions&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> ourRegex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">expressions</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
ourStr<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>ourRegex<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这里第一个 <code>match</code> 将返回 <code>[&quot;Hello&quot;]</code> 第二个将返回 <code>[&quot;expressions&quot;]</code>。</p> <p>请注意， <code>.match</code> 语法是目前为止一直使用的 <code>.test</code> 方法中的“反向”：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token string">'string'</span><span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">regex</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">regex</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'string'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="全局匹配"><a href="#全局匹配" class="header-anchor">#</a> 全局匹配</h2> <p>到目前为止，只能提取或搜寻一次模式匹配。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> testStr <span class="token operator">=</span> <span class="token string">&quot;Repeat, Repeat, Repeat&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> ourRegex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">Repeat</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
testStr<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>ourRegex<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在这里 <code>match</code> 将返回 <code>[&quot;Repeat&quot;]</code>。</p> <p>若要多次搜寻或提取模式匹配，可以使用 <code>g</code> 标志。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> repeatRegex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">Repeat</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
testStr<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>repeatRegex<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这里 <code>match</code> 返回值 <code>[&quot;Repeat&quot;, &quot;Repeat&quot;, &quot;Repeat&quot;]</code></p> <div class="custom-block warning"><p class="custom-block-title">注意</p> <p>在正则表达式上可以有多个标志，比如 <code>/search/gi</code></p></div> <h2 id="用通配符匹配任何内容"><a href="#用通配符匹配任何内容" class="header-anchor">#</a> 用通配符匹配任何内容</h2> <p>有时不（或不需要）知道匹配模式中的确切字符。 如果要精确匹配到完整的单词，那出现一个拼写错误就会匹配不到。 幸运的是，可以使用通配符 <code>.</code> 来处理这种情况。</p> <p>通配符 <code>.</code> 将匹配任何一个字符。 通配符也叫 <code>dot</code> 或 <code>period</code>。 可以像使用正则表达式中任何其他字符一样使用通配符。 例如，如果想匹配 <code>hug</code>、<code>huh</code>、<code>hut</code> 和 <code>hum</code>，可以使用正则表达式 <code>/hu./</code> 匹配以上四个单词。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> humStr <span class="token operator">=</span> <span class="token string">&quot;I'll hum a song&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> hugStr <span class="token operator">=</span> <span class="token string">&quot;Bear hug&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> huRegex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">hu.</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
huRegex<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>humStr<span class="token punctuation">)</span><span class="token punctuation">;</span>
huRegex<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>hugStr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>上面的 <code>test</code> 都会返回 <code>true</code>。</p> <h2 id="将单个字符与多种可能性匹配"><a href="#将单个字符与多种可能性匹配" class="header-anchor">#</a> 将单个字符与多种可能性匹配</h2> <p>已经了解了文字匹配模式（<code>/literal/</code>）和通配符（<code>/./</code>）。 这是正则表达式的两种极端情况，一种是精确匹配，而另一种则是匹配所有。 在这两种极端情况之间有一个平衡选项。</p> <p>可以使用字符集 （character classes）更灵活的匹配字符。 可以把字符集放在方括号（<code>[</code> 和 <code>]</code>）之间来定义一组需要匹配的字符串。</p> <p>例如，如果想要匹配 <code>bag</code>、<code>big</code> 和 <code>bug</code>，但是不想匹配 <code>bog</code>。 可以创建正则表达式 <code>/b[aiu]g/</code> 来执行此操作。 <code>[aiu]</code> 是只匹配字符 <code>a</code>、<code>i</code> 或者 <code>u</code> 的字符集。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> bigStr <span class="token operator">=</span> <span class="token string">&quot;big&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> bagStr <span class="token operator">=</span> <span class="token string">&quot;bag&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> bugStr <span class="token operator">=</span> <span class="token string">&quot;bug&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> bogStr <span class="token operator">=</span> <span class="token string">&quot;bog&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> bgRegex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">b[aiu]g</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
bigStr<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>bgRegex<span class="token punctuation">)</span><span class="token punctuation">;</span>
bagStr<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>bgRegex<span class="token punctuation">)</span><span class="token punctuation">;</span>
bugStr<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>bgRegex<span class="token punctuation">)</span><span class="token punctuation">;</span>
bogStr<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>bgRegex<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>按顺序排列，四次 <code>match</code> 调用将返回值 <code>[&quot;big&quot;]</code>、<code>[&quot;bag&quot;]</code>、<code>[&quot;bug&quot;]</code> 和 <code>null</code>。</p> <h2 id="匹配字母表中的字母"><a href="#匹配字母表中的字母" class="header-anchor">#</a> 匹配字母表中的字母</h2> <p>了解了如何使用字符集（character sets）来指定要匹配的一组字符串，但是有时需要匹配大量字符（例如，字母表中的每个字母）。 有一种写法可以让实现这个功能变得简短。</p> <p>在字符集中，可以使用连字符（<code>-</code>）来定义要匹配的字符范围。</p> <p>例如，要匹配小写字母 <code>a</code> 到 <code>e</code>，你可以使用 <code>[a-e]</code>。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> catStr <span class="token operator">=</span> <span class="token string">&quot;cat&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> batStr <span class="token operator">=</span> <span class="token string">&quot;bat&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> matStr <span class="token operator">=</span> <span class="token string">&quot;mat&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> bgRegex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[a-e]at</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
catStr<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>bgRegex<span class="token punctuation">)</span><span class="token punctuation">;</span>
batStr<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>bgRegex<span class="token punctuation">)</span><span class="token punctuation">;</span>
matStr<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>bgRegex<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>按顺序排列，三次 <code>match</code> 调用将返回值 <code>[&quot;cat&quot;]</code>，<code>[&quot;bat&quot;]</code> 和 <code>null</code>。</p> <h2 id="匹配字母表中的数字和字母"><a href="#匹配字母表中的数字和字母" class="header-anchor">#</a> 匹配字母表中的数字和字母</h2> <p>使用连字符（<code>-</code>）匹配字符范围并不仅限于字母。 它还可以匹配一系列数字。</p> <p>例如，<code>/[0-5]/</code> 匹配 <code>0</code> 和 <code>5</code> 之间的任意数字，包含 <code>0</code> 和 <code>5</code>。</p> <p>此外，还可以在单个字符集中组合一系列字母和数字。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> jennyStr <span class="token operator">=</span> <span class="token string">&quot;Jenny8675309&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> myRegex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[a-z0-9]</span><span class="token regex-delimiter">/</span><span class="token regex-flags">ig</span></span><span class="token punctuation">;</span>
jennyStr<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>myRegex<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="匹配单个未指定的字符"><a href="#匹配单个未指定的字符" class="header-anchor">#</a> 匹配单个未指定的字符</h2> <p>到目前为止，已经创建了一个想要匹配的字符集合，但也可以创建一个不想匹配的字符集合。 这些类型的字符集称为否定字符集（ negated character sets）。</p> <p>要创建否定字符集，需要在开始括号后面和不想匹配的字符前面放置脱字符（即<code>^</code>）。</p> <p>例如，<code>/[^aeiou]/gi</code> 匹配所有非元音字符。 注意，字符 <code>.</code>、<code>!</code>、<code>[</code>、<code>@</code>、<code>/</code> 和空白字符等也会被匹配，该否定字符集仅排除元音字符。</p> <h2 id="匹配出现一次或多次的字符"><a href="#匹配出现一次或多次的字符" class="header-anchor">#</a> 匹配出现一次或多次的字符</h2> <p>有时，需要匹配出现一次或者连续多次的的字符（或字符组）。 这意味着它至少出现一次，并且可能重复出现。</p> <p>可以使用 <code>+</code> 符号来检查情况是否如此。 记住，字符或匹配模式必须一个接一个地连续出现。 这就是说，字符必须一个接一个地重复。</p> <p>例如，<code>/a+/g</code> 会在 <code>abc</code> 中匹配到一个匹配项，并且返回 <code>[&quot;a&quot;]</code>。 因为 <code>+</code> 的存在，它也会在 <code>aabc</code> 中匹配到一个匹配项，然后返回 <code>[&quot;aa&quot;]</code>。</p> <p>如果它是检查字符串 <code>abab</code>，它将匹配到两个匹配项并且返回<code>[&quot;a&quot;, &quot;a&quot;]</code>，因为<code>a</code>字符不连续，在它们之间有一个<code>b</code>字符。 最后，因为在字符串 <code>bcd</code> 中没有 <code>a</code>，因此找不到匹配项。</p> <h2 id="匹配出现零次或多次的字符"><a href="#匹配出现零次或多次的字符" class="header-anchor">#</a> 匹配出现零次或多次的字符</h2> <p>上面使用了加号 <code>+</code> 来查找出现一次或多次的字符。 还有一个选项可以匹配出现零次或多次的字符。</p> <p>执行该操作的字符叫做星号，即<code>*</code>。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> soccerWord <span class="token operator">=</span> <span class="token string">&quot;gooooooooal!&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> gPhrase <span class="token operator">=</span> <span class="token string">&quot;gut feeling&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> oPhrase <span class="token operator">=</span> <span class="token string">&quot;over the moon&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> goRegex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">go*</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
soccerWord<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>goRegex<span class="token punctuation">)</span><span class="token punctuation">;</span>
gPhrase<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>goRegex<span class="token punctuation">)</span><span class="token punctuation">;</span>
oPhrase<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>goRegex<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>按顺序排列，三次 <code>match</code> 调用将返回值 <code>[&quot;goooooooo&quot;]</code>，<code>[&quot;g&quot;]</code> 和 <code>null</code>。</p> <h2 id="用惰性匹配来查找字符"><a href="#用惰性匹配来查找字符" class="header-anchor">#</a> 用惰性匹配来查找字符</h2> <p>在正则表达式中，贪婪（greedy）匹配会匹配到符合正则表达式匹配模式的字符串的最长可能部分，并将其作为匹配项返回。 另一种方案称为懒惰（lazy）匹配，它会匹配到满足正则表达式的字符串的最小可能部分。</p> <p>可以将正则表达式 <code>/t[a-z]*i/</code> 应用于字符串 <code>&quot;titanic&quot;</code>。 这个正则表达式是一个以 <code>t</code> 开始，以 <code>i</code> 结束，并且中间有一些字母的匹配模式。</p> <p>正则表达式默认是贪婪匹配，因此匹配返回为 <code>[&quot;titani&quot;]</code>。 它会匹配到适合该匹配模式的最大子字符串。</p> <p>但是，你可以使用 <code>?</code> 字符来将其变成懒惰匹配。 调整后的正则表达式 <code>/t[a-z]*?i/</code> 匹配字符串 <code>&quot;titanic&quot;</code> 返回 <code>[&quot;ti&quot;]</code>。</p> <div class="custom-block warning"><p class="custom-block-title">注意</p> <p>应该避免使用正则表达式解析 HTML，但是可以用正则表达式匹配 HTML 字符串。</p></div> <h2 id="匹配字符串的开头"><a href="#匹配字符串的开头" class="header-anchor">#</a> 匹配字符串的开头</h2> <p>回顾一下之前的学习，正则表达式可以用于查找多项匹配。 还可以查询字符串中符合指定匹配模式的字符。</p> <p>在之前的挑战中，使用字符集中前插入符号（<code>^</code>）来创建一个否定字符集，形如 <code>[^thingsThatWillNotBeMatched]</code>。 除了在字符集中使用之外，脱字符还用于匹配字符串的开始位置。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> firstString <span class="token operator">=</span> <span class="token string">&quot;Ricky is first and can be found.&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> firstRegex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^Ricky</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
firstRegex<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>firstString<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> notFirst <span class="token operator">=</span> <span class="token string">&quot;You can't find Ricky now.&quot;</span><span class="token punctuation">;</span>
firstRegex<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>notFirst<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>第一次 <code>test</code> 调用将返回 <code>true</code>，而第二次调用将返回 <code>false</code>。</p> <h2 id="匹配字符串的末尾"><a href="#匹配字符串的末尾" class="header-anchor">#</a> 匹配字符串的末尾</h2> <p>在上一节中，学习了使用脱字符号来搜寻字符串的开始位置。 还有一种方法可以搜寻字符串末尾的匹配模式。</p> <p>可以使用正则表达式的美元符号 <code>$</code> 来搜寻字符串的结尾。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> theEnding <span class="token operator">=</span> <span class="token string">&quot;This is a never ending story&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> storyRegex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">story$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
storyRegex<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>theEnding<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> noEnding <span class="token operator">=</span> <span class="token string">&quot;Sometimes a story will have to end&quot;</span><span class="token punctuation">;</span>
storyRegex<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>noEnding<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>第一次 <code>test</code> 调用将返回 <code>true</code>, 而第二次调用将返回 <code>false</code>。</p> <h2 id="匹配所有的字母和数字"><a href="#匹配所有的字母和数字" class="header-anchor">#</a> 匹配所有的字母和数字</h2> <p>使用元字符，可以使用 <code>[a-z]</code> 搜寻字母表中的所有字母。 这种元字符是很常见的，它有一个缩写，但这个缩写也包含额外的字符。</p> <p>JavaScript 中与字母表匹配的最接近的元字符是<code>\w</code>。 这个缩写等同于<code>[A-Za-z0-9_]</code>。 此字符类匹配大写字母和小写字母以及数字。 注意，这个字符类也包含下划线字符 (<code>_</code>)。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> longHand <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">[A-Za-z0-9_]+</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
<span class="token keyword">let</span> shortHand <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\w+</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
<span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token string">&quot;42&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> varNames <span class="token operator">=</span> <span class="token string">&quot;important_var&quot;</span><span class="token punctuation">;</span>
longHand<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token punctuation">;</span>
shortHand<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>numbers<span class="token punctuation">)</span><span class="token punctuation">;</span>
longHand<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>varNames<span class="token punctuation">)</span><span class="token punctuation">;</span>
shortHand<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>varNames<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>上面的 <code>test</code> 都会返回 <code>true</code>。</p> <p>这些元字符缩写也被称为短语元字符 shorthand character classes。</p> <h2 id="匹配除了字母和数字的所有符号"><a href="#匹配除了字母和数字的所有符号" class="header-anchor">#</a> 匹配除了字母和数字的所有符号</h2> <p>已经了解到可以使用缩写 <code>\w</code> 来匹配字母和数字 <code>[A-Za-z0-9_]</code>。 不过，有可能想要搜寻的匹配模式是非字母数字字符。</p> <p>可以使用 <code>\W</code> 搜寻和 <code>\w</code> 相反的匹配模式。 注意，相反匹配模式使用大写字母。 此缩写与 <code>[^A-Za-z0-9_]</code> 是一样的。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> shortHand <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\W</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
<span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token string">&quot;42%&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> sentence <span class="token operator">=</span> <span class="token string">&quot;Coding!&quot;</span><span class="token punctuation">;</span>
numbers<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>shortHand<span class="token punctuation">)</span><span class="token punctuation">;</span>
sentence<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>shortHand<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>第一次 <code>match</code> 调用将返回值 <code>[&quot;%&quot;]</code> 而第二次调用将返回 <code>[&quot;!&quot;]</code>。</p> <h2 id="匹配所有数字"><a href="#匹配所有数字" class="header-anchor">#</a> 匹配所有数字</h2> <p>已经了解了常见字符串匹配模式的元字符，如字母数字。 另一个常见的匹配模式是只寻找数字。</p> <p>查找数字字符的缩写是 <code>\d</code>，注意是小写的 <code>d</code>。 这等同于元字符 <code>[0-9]</code>，它查找 0 到 9 之间任意数字的单个字符。</p> <h2 id="匹配所有非数字"><a href="#匹配所有非数字" class="header-anchor">#</a> 匹配所有非数字</h2> <p>上一节中展示了如何使用带有小写 <code>d</code> 的缩写 <code>\d</code> 来搜寻数字。 也可以使用类似的缩写来搜寻非数字，该缩写使用大写的 <code>D</code>。</p> <p>查找非数字字符的缩写是 <code>\D</code>。 这等同于字符串 <code>[^0-9]</code>，它查找不是 0 - 9 之间数字的单个字符。</p> <h2 id="匹配空白字符"><a href="#匹配空白字符" class="header-anchor">#</a> 匹配空白字符</h2> <p>迄今为止学习了包括匹配字母和数字。 还可以匹配字符之间的空格。</p> <p>可以使用 <code>\s</code> 搜寻空格，其中 <code>s</code> 是小写。 此匹配模式将匹配空格、回车符、制表符、换页符和换行符。 可以认为这类似于元字符 <code>[ \r\t\f\n\v]</code>。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> whiteSpace <span class="token operator">=</span> <span class="token string">&quot;Whitespace. Whitespace everywhere!&quot;</span>
<span class="token keyword">let</span> spaceRegex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\s</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
whiteSpace<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>spaceRegex<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这个 <code>match</code> 调用将返回 <code>[&quot; &quot;, &quot; &quot;]</code>。</p> <h2 id="匹配非空白字符"><a href="#匹配非空白字符" class="header-anchor">#</a> 匹配非空白字符</h2> <p>已经学会了如何使用带有小写 <code>s</code> 的缩写 <code>\s</code> 来搜寻空白字符。 还可以搜寻除了空格之外的所有内容。</p> <p>使用 <code>\S</code> 搜寻非空白字符，其中 <code>s</code> 是大写。 此匹配模式将不匹配空格、回车符、制表符、换页符和换行符。 可以认为这类似于元字符 <code>[^ \r\t\f\n\v]</code>。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> whiteSpace <span class="token operator">=</span> <span class="token string">&quot;Whitespace. Whitespace everywhere!&quot;</span>
<span class="token keyword">let</span> nonSpaceRegex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\S</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
whiteSpace<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>nonSpaceRegex<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>返回值的 <code>.length</code> 应该是 <code>32</code>。</p> <h2 id="指定匹配的上限和下限"><a href="#指定匹配的上限和下限" class="header-anchor">#</a> 指定匹配的上限和下限</h2> <p>回想一下，使用加号 <code>+</code> 查找一个或多个字符，使用星号 <code>*</code> 查找零个或多个字符。 这些都很方便，但有时需要匹配一定范围的匹配模式。</p> <p>可以使用数量说明符（quantity specifiers）指定匹配模式的上下限。 数量说明符与花括号（<code>{</code> 和 <code>}</code>）一起使用。 可以在花括号之间放两个数字，这两个数字代表匹配模式的上限和下限。</p> <p>例如，要匹配出现 <code>3</code> 到 <code>5</code> 次字母 <code>a</code> 的在字符串 <code>ah</code>，正则表达式应为<code>/a{3,5}h/</code>。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token constant">A4</span> <span class="token operator">=</span> <span class="token string">&quot;aaaah&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token constant">A2</span> <span class="token operator">=</span> <span class="token string">&quot;aah&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> multipleA <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">a{3,5}h</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
multipleA<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token constant">A4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
multipleA<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token constant">A2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>第一次 <code>test</code> 调用将返回 <code>true</code>，而第二次调用将返回 <code>false</code>。</p> <h2 id="只指定匹配的下限"><a href="#只指定匹配的下限" class="header-anchor">#</a> 只指定匹配的下限</h2> <p>可以使用带有花括号的数量说明符来指定匹配模式的上下限。 但有时候只想指定匹配模式的下限而不需要指定上限。</p> <p>为此，在第一个数字后面跟一个逗号即可。</p> <p>例如，要匹配至少出现 <code>3</code> 次字母 <code>a</code> 的字符串 <code>hah</code>，正则表达式应该是 <code>/ha{3,}h/</code>。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token constant">A4</span> <span class="token operator">=</span> <span class="token string">&quot;haaaah&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token constant">A2</span> <span class="token operator">=</span> <span class="token string">&quot;haah&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token constant">A100</span> <span class="token operator">=</span> <span class="token string">&quot;h&quot;</span> <span class="token operator">+</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;h&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> multipleA <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">ha{3,}h</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
multipleA<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token constant">A4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
multipleA<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token constant">A2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
multipleA<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token constant">A100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>按顺序排列，三次 <code>test</code> 调用将返回值 <code>true</code>，<code>false</code> 和 <code>true</code>。</p> <h2 id="指定匹配的确切数量"><a href="#指定匹配的确切数量" class="header-anchor">#</a> 指定匹配的确切数量</h2> <p>可以使用带有花括号的数量说明符来指定匹配模式的上下限。 但有时只需要特定数量的匹配。</p> <p>要指定一定数量的匹配模式，只需在大括号之间放置一个数字。</p> <p>例如，要只匹配字母 <code>a</code> 出现 <code>3</code> 次的单词<code>hah</code>，正则表达式应为<code>/ha{3}h/</code>。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token constant">A4</span> <span class="token operator">=</span> <span class="token string">&quot;haaaah&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token constant">A3</span> <span class="token operator">=</span> <span class="token string">&quot;haaah&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token constant">A100</span> <span class="token operator">=</span> <span class="token string">&quot;h&quot;</span> <span class="token operator">+</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;h&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> multipleHA <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">ha{3}h</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
multipleHA<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token constant">A4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
multipleHA<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token constant">A3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
multipleHA<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token constant">A100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>按顺序排列，三次 <code>test</code> 调用将返回值 <code>false</code>，<code>true</code> 和 <code>false</code>。</p> <h2 id="检查全部或无"><a href="#检查全部或无" class="header-anchor">#</a> 检查全部或无</h2> <p>有时，想要搜寻的匹配模式可能有不确定是否存在的部分。 尽管如此，还是想检查它们。</p> <p>为此，可以使用问号 <code>?</code> 指定可能存在的元素。 这将检查前面的零个或一个元素。 可以将此符号视为前面的元素是可选的。</p> <p>例如，美式英语和英式英语略有不同，可以使用问号来匹配两种拼写。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> american <span class="token operator">=</span> <span class="token string">&quot;color&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> british <span class="token operator">=</span> <span class="token string">&quot;colour&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> rainbowRegex<span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">colou?r</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
rainbowRegex<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>american<span class="token punctuation">)</span><span class="token punctuation">;</span>
rainbowRegex<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>british<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>上面的 <code>test</code> 都会返回 <code>true</code>。</p> <h2 id="正向先行断言和负向先行断言"><a href="#正向先行断言和负向先行断言" class="header-anchor">#</a> 正向先行断言和负向先行断言</h2> <p>先行断言 （Lookaheads）是告诉 JavaScript 在字符串中向前查找的匹配模式。 当想要在同一个字符串上搜寻多个匹配模式时，这可能非常有用。</p> <p>有两种先行断言：正向先行断言（positive lookahead）和负向先行断言（negative lookahead）。</p> <p>正向先行断言会查看并确保搜索匹配模式中的元素存在，但实际上并不匹配。 正向先行断言的用法是 <code>(?=...)</code>，其中 <code>...</code> 就是需要存在但不会被匹配的部分。</p> <p>另一方面，负向先行断言会查看并确保搜索匹配模式中的元素不存在。 负向先行断言的用法是 <code>(?!...)</code>，其中 <code>...</code> 是希望不存在的匹配模式。 如果负向先行断言部分不存在，将返回匹配模式的其余部分。</p> <p>尽管先行断言有点儿令人困惑，但是这些示例会有所帮助。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> quit <span class="token operator">=</span> <span class="token string">&quot;qu&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> noquit <span class="token operator">=</span> <span class="token string">&quot;qt&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> quRegex<span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">q(?=u)</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
<span class="token keyword">let</span> qRegex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">q(?!u)</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
quit<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>quRegex<span class="token punctuation">)</span><span class="token punctuation">;</span>
noquit<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>qRegex<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这两次 <code>match</code> 调用都将返回 <code>[&quot;q&quot;]</code>。</p> <p>先行断言的更实际用途是检查一个字符串中的两个或更多匹配模式。 这里有一个简单的密码检查器，密码规则是 3 到 6 个字符且至少包含一个数字：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> password <span class="token operator">=</span> <span class="token string">&quot;abc123&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> checkPass <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?=\w{3,6})(?=\D*\d)</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
checkPass<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="检查混合字符组"><a href="#检查混合字符组" class="header-anchor">#</a> 检查混合字符组</h2> <p>有时候我们想使用正则表达式里的括号 <code>()</code> 来检查字符组。</p> <p>如果想在字符串找到 <code>Penguin</code> 或 <code>Pumpkin</code>，可以用这个正则表达式：<code>/P(engu|umpk)in/g</code>。</p> <p>然后使用 <code>test()</code> 方法检查 test 字符串里面是否包含字符组。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> testStr <span class="token operator">=</span> <span class="token string">&quot;Pumpkin&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> testRegex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">P(engu|umpk)in</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
testRegex<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>testStr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>test</code> 方法会返回 <code>true</code>。</p> <h2 id="使用捕获组重用模式"><a href="#使用捕获组重用模式" class="header-anchor">#</a> 使用捕获组重用模式</h2> <p>当你想要匹配一个像下面这样多次出现的单词，</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> repeatStr <span class="token operator">=</span> <span class="token string">&quot;row row row your boat&quot;</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>你可以使用 <code>/row row row/</code>。但如果你不知道重复的特定单词，怎么办？ 捕获组 可以用于找到重复的子字符串。</p> <p>捕获组是通过把要捕获的正则表达式放在括号中来构建的。 在这个例子里， 目标是捕获一个包含字母数字字符的词，所以捕获组是将 <code>\w+</code> 放在括号中：<code>/(\w+)/</code>。</p> <p>分组匹配的子字符串被保存到一个临时的“变量”， 可以使用同一正则表达式和反斜线及捕获组的编号来访问它（例如：<code>\1</code>）。 捕获组按其开头括号的位置自动编号（从左到右），从 1 开始。</p> <p>下面的示例是匹配被空格隔开的两个相同单词：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> repeatRegex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(\w+) \1 \1</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
repeatRegex<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>repeatStr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Returns true</span>
repeatStr<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>repeatRegex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Returns [&quot;row row row&quot;, &quot;row&quot;]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在字符串上调用 <code>.match()</code> 方法将返回一个数组，其中包含它最终匹配到的子字符串及其捕获组。</p> <h2 id="使用捕获组搜索和替换"><a href="#使用捕获组搜索和替换" class="header-anchor">#</a> 使用捕获组搜索和替换</h2> <p>搜索功能是很有用的。 但是，当搜索同时也执行更改（或替换）匹配文本的操作时，搜索功能就会显得更加强大。</p> <p>可以在字符串上使用 <code>.replace()</code> 方法来搜索并替换字符串中的文本。 <code>.replace()</code> 的输入首先是想要搜索的正则表达式匹配模式。 第二个参数是用于替换匹配的字符串或用于执行某些操作的函数。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> wrongText <span class="token operator">=</span> <span class="token string">&quot;The sky is silver.&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> silverRegex <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">silver</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
wrongText<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>silverRegex<span class="token punctuation">,</span> <span class="token string">&quot;blue&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>replace</code> 调用将返回字符串 <code>The sky is blue.</code>。</p> <p>你还可以使用美元符号（<code>$</code>）访问替换字符串中的捕获组。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token string">&quot;Code Camp&quot;</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(\w+)\s(\w+)</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span> <span class="token string">'$2 $1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>调用 <code>replace</code> 将返回字符串 <code>Camp Code</code>。</p> <div class="custom-block tip"><p class="custom-block-title">更多</p> <p><a href="https://www.runoob.com/regexp/regexp-tutorial.html" target="_blank" rel="noopener noreferrer">正则表达式 – 教程 | 菜鸟教程 (runoob.com)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/notes/front-end/JavaScript/ES6.html" class="prev">
        ES6
      </a></span> <!----></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/notes/assets/js/app.98e544da.js" defer></script><script src="/notes/assets/js/2.5375f91f.js" defer></script><script src="/notes/assets/js/14.89fb7710.js" defer></script>
  </body>
</html>
